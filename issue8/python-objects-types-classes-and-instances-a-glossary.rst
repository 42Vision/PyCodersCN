对象、类型、类和实例——Python术语汇编
===================================

原文： `<http://eli.thegreenplace.net/2012/03/30/python-objects-types-classes-and-instances-a-glossary/>`_

译者：  Ruici Luo

当我在写另一篇文章 `internal of Python callables <http://eli.thegreenplace.net/2012/03/23/python-internals-how-callables-work/>`_ 时，我想到 Python 中的有些东西会拥有多个的名字。同时，某些名字有时候也会指代多个实体，其中哪一个实体是被隐式指定的需要根据上下文信息来判定。因此，为了今后写文章的方便，将这类命名法放在一个单独的地方是一个不错的主意。这样我就能够在任何讨论到这些主题的时候链接到这里，而不是一次又一次地解释他们。

特别地，我会先定义我所说的的类型、对象、类和实例。需要注意的是这里的依据是 Python 3.x，当然大多数情况下也是适用于 Python 2.x 的[1]。

对象
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
对象是最容易定义的，Python 的 `data model reference <http://docs.python.org/dev/reference/datamodel.html>`_ 中就有一个很漂亮的定义：

::

    对象是 Python 对数据的抽象。Python 程序中的所有数据都通过对象以及对象之间的关系来表示。（在某种意义上，代码也是通过对象来表示的，这与冯诺依曼模型中的“存储程序计算机”是一致的）

    每一个对象都拥有 id，类型和值

所以，Python 中的一切事物都是对象。列表、42、模块、函数都是对象。Python 字节码都是以对象的形式存在的。所有这些都拥有类型以及唯一的 ID：

::

    >>> def foo(): pass
    ...
    >>> type(foo), id(foo)
    (<class 'function'>, 38110760)
    >>> type(foo.__code__), id(foo.__code__)
    (<class 'code'>, 38111680)

这样的“一切事物都是对象”的模型被 CPython 实现所支持。事实上，如果你阅读了 CPython 源代码，你就会注意到每上述提到的每一个实体都可以通过一个指向基结构体 PyObject 的指针来操作。

类型
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Python data model reference 中的定义如下：

::

    对象的类型决定了对象所支持的操作（例如，它可以计算长度吗？）并且定义了该类型对象的可能取值。

所以，Python 中的每一个对象都拥有类型，类型的信息可以通过调用内置函数 ``type`` 得到[2]；类型同样也是对象，所以他也有自己的类型—— ``type`` 。后面一条可能在你编写 Python 代码时并没有太大用处，但是它于理解 CPython 的内部机制有着巨大的作用：

::

    >>> type(42)
    <class 'int'>
    >>> type(type(42))
    <class 'type'>
    >>> type(type(type(42)))
    <class 'type'>

是啊，这就像一只一只一直驮着下去的乌龟群啊。（译者注：这段文字源自 Stephen Hawking 的《时间简史》开头一位著名科学家与老妇人的对话，这里意指 ``type`` 可以不停嵌套下去）

类
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
过去，用户定义的类与内置类型之间是有区别的。但是从2.2版本以后，只要使用“新式”的类（2.x中继承于 ``object`` 的类，在3.x中是默认的），他们之间就不再有区别。本质上，类是 Python 提供的一种在代码中定义新的用户定义类型 (user-defined type) 的机制。

::

    >>> class Joe: pass
    ...
    >>> j = Joe()
    >>> type(j)
    <class '__main__.Joe'>

 使用这样的机制我们创建了一种新的用户定义类型—— ``Joe`` 。 ``j`` 是类 ``Joe`` 的一个实例，换句话说， ``j`` 是一个对象，它的类型是 ``Joe`` 。

 就像其他类型一样， ``Joe`` 本身也是一个对象并且拥有自己的类型。他的类型就是 ``type`` ：

 ::

    >>> type(type(j))
    <class 'type'>

术语“类”和“类型”就是两个名字对应同一概念的一个例子。为了避免这种混乱，当我意指类型 (type) 时我会使用“type”，而意指使用 ``class`` 关键字创建的新类型时，我会使用“user-defined class”。需要注意，当我们使用 CPython 的 C API 创建新类型，并不会提到 class——因为我们仅仅创建了一个新的类型 (type)，而不是类 (class)。

实例
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
和类与类型之间存在歧义一样，“实例 (instance)”和“对象 (object)”也是同义的。用这种方式考虑：对象是类型的实例 (objects are instances of types)。所以，“42是类型int的一个实例”和“42是一个int对象”是等价的。我经常互换使用“实例”和“对象”，有时候当我特指那些 CPython 实现的制品的对象时，我会使用“实例”来指代类的实际对象。另外一个显示使用术语“实例”的地方是像 ``isinstance`` 这样的内置函数以及特殊的 ``__instancecheck__`` 属性。

结论
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
就像我们看到的，在 Python 术语表里有两对意义大致接近的术语。类型和类是可以相互交换的概念，只要有可能我会更愿意使用类型，只有当使用关键字 ``class`` 创建的用户定义类型时才使用术语 class。在我看来，“类型”是一个更好的术语，即使 class 概念被完全从 Python 中去除，Python 也不会更糟糕。

类似地，对象和实例也是有着相同意义的术语，可能有微小的不同。有时候使用“实例”会更加方便（例如当明确地谈到某特定对象是某特定类型的实例时——“ ``j`` 是 ``Joe`` 的实例”），但有时候使用“对象”会更好（例如讨论 CPython 实现的内部机制时）

我真诚地希望这篇文章能让你从混乱中解脱出来。对我来说，当我在别的文章中提到这些可能不清楚或者有歧义的术语时，这里可以充当一个术语表的角色。

[1] 只要不考虑2.x中传统类的存在，即认为所有用户定义类都是继承于 ``object`` 的。

[2] 一个可以替代的选择是 ``__class__`` 属性
