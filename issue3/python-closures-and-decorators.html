
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Python 的闭包和装饰器 &mdash; PyCoder&#39;s Weelky CN</title>
    
    <link rel="stylesheet" href="../static/pyramid.css" type="text/css" />
    <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
    <style type="text/css">.reference em {font-style: normal; } a tt {font-size: 1.2em; font-weight: normal; }</style>
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../static/jquery.js"></script>
    <script type="text/javascript" src="../static/underscore.js"></script>
    <script type="text/javascript" src="../static/doctools.js"></script>
    <link rel="top" title="PyCoder&#39;s Weelky CN" href="../index.html" />
    <link rel="up" title="issue 3: Code Hard" href="index.html" />
    <link rel="prev" title="AST 模块：用 Python 修改 Python 代码" href="static-modification-of-python-with-python-the-ast-module.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li><a href="../index.html">PyCoder&#39;s Weelky CN</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">issue 3: Code Hard</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="python">
<span id="toctree-directive"></span><h1>Python 的闭包和装饰器<a class="headerlink" href="#python" title="Permalink to this headline">¶</a></h1>
<p>翻译： <a class="reference external" href="http://zhuang13.de">TheLover_Z</a></p>
<div class="section" id="part-i">
<h2>Part I<a class="headerlink" href="#part-i" title="Permalink to this headline">¶</a></h2>
<p>原文地址： <a class="reference external" href="http://blaag.haard.se/Python-Closures-and-Decorators--Pt--1/">http://blaag.haard.se/Python-Closures-and-Decorators&#8211;Pt&#8211;1/</a></p>
<p>回想起来，当初我做出了错误的选择，把 Python 的课程削减到了4个小时以至于把装饰器的部分搞砸了，我答应大家我稍后会对闭包和装饰器做一个更好的解说 —— 我是这么打算的。</p>
<p>函数也是对象。实际上，在 Python 中函数是一级对象——也就是说，他们可以像其他对象一样使用而没有什么特别的限制。这给了我们一些有趣的选择，我会由浅到深解释这个问题。</p>
<p>关于函数就是对象的一个最常见的例子就是 C 中的函数指针；将函数传递到其他的将要使用它的函数。为了说明这一点，我们来看看一个重复函数的实现 —— 也就是，一个函数接受另外一个函数以及一个数字当作参数，并且重复调用指定函数指定次数：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c">#A very simple function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">greeter</span><span class="p">():</span>
<span class="go">…     print(&quot;Hello&quot;)</span>
<span class="go">…</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#An implementation of a repeat function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">times</span><span class="p">):</span>
<span class="go">…     for i in rannge(times):</span>
<span class="go">…         fn()</span>
<span class="go">…</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">repeat</span><span class="p">(</span><span class="n">greeter</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">Hello</span>
<span class="go">Hello</span>
<span class="go">Hello</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这种模式在很多情况下都有用 —— 比如向一个排序算法传递比较函数，向一个语法分析器传递一个装饰器函数，通常情况下这些做法可以使一个函数的行为 <strong>更专一化</strong> ，或者向已经抽象了工作流的函数传递一个待办的特定部分（比如， <tt class="docutils literal"><span class="pre">sort()</span></tt> 知道怎么排序， <tt class="docutils literal"><span class="pre">compare()</span></tt> 知道怎么比较元素）。</p>
<p>函数也可以在其他函数的内部声明，这给了我们另一个很重要的工具。在一般情况下，这可以用来隐藏实用函数的实现细节：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">print_integers</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
<span class="go">…     def is_integer(value):</span>
<span class="go">…         try:</span>
<span class="go">…             return value == int(value)</span>
<span class="go">…         except:</span>
<span class="go">…             return False</span>
<span class="go">…     for v in values:</span>
<span class="go">…         if is_integer(v):</span>
<span class="go">…             print(v)</span>
<span class="go">…</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_integers</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="s">&quot;4&quot;</span><span class="p">,</span> <span class="s">&quot;parrot&quot;</span><span class="p">,</span> <span class="mf">3.14</span><span class="p">])</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">3</span>
</pre></div>
</div>
<p>这可能是有用的，但它本身并不算是个强大的工具。相比函数可以当作参数被传递而言，我们可以将它们包装（wrap）在另外的函数中，从而向已经构建好的函数增加新的行为。一个简单的例子是向一个函数增加跟踪输出：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">print_call</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
<span class="go">…     def fn_wrap(*args, **args): #take any arguments</span>
<span class="go">…         print (&quot;Calling %s&quot; % (fn.func_name))</span>
<span class="go">…         return fn(*args, **kwargs) #pass any arguments to fn()</span>
<span class="go">…     return fn_wrap</span>
<span class="go">…</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">greeter</span> <span class="o">=</span> <span class="n">print_call</span><span class="p">(</span><span class="n">greeter</span><span class="p">)</span> <span class="c">#wrap greeter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">repeat</span><span class="p">(</span><span class="n">greeter</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">Calling fn_wrap</span>
<span class="go">Hello</span>
<span class="go">Calling fn_wrap</span>
<span class="go">Hello</span>
<span class="go">Calling fn_wrap</span>
<span class="go">Hello</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">greeter</span><span class="o">.</span><span class="n">func_name</span>
<span class="go">&#39;fn_wrap&#39;</span>
</pre></div>
</div>
<p>正如你看到的那样，我们可以使用带日志的函数来替换掉现有函数相应的部分，然后调用原来的函数。在例子的最后两行，函数的名字已经反映出了它已经被改变，这个改变可能是我们想要的，也可能不是。如果我们想包装一个函数同时保持它原来的名字，我们可以增加一行 <tt class="docutils literal"><span class="pre">print_call</span></tt> 函数，代码如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">print_call</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
<span class="go">…     def fn_wrap(*args, **kwargs): #take any arguments</span>
<span class="go">…         print(&quot;Calling %s&quot; % (fn.func_name))</span>
<span class="go">…         return fn(*args, **kwargs) #pass any arguments to fn()</span>
<span class="go">…     fn_wrap.func_name = fn.func_name #Copy the original name</span>
<span class="go">…     return fn_wrap</span>
</pre></div>
</div>
<p>因为这是一个很长的话题，我明天会来更新第二部分，我们会讲讲闭包，偏函数（partial），还有（终于到它了）装饰器。</p>
<p>至此，如果这些你之前全部没有接触过，可以先用 <tt class="docutils literal"><span class="pre">print_call</span></tt> 函数作为基础，来创建一个能够在正常调用函数之前先打印出这个函数名字的一个修饰器。</p>
</div>
<div class="section" id="part-ii">
<h2>Part II<a class="headerlink" href="#part-ii" title="Permalink to this headline">¶</a></h2>
<p>原文地址： <a class="reference external" href="http://blaag.haard.se/Python-Closures-and-Decorators--Pt--2/">http://blaag.haard.se/Python-Closures-and-Decorators&#8211;Pt&#8211;2/</a></p>
<p>在第一部分中，我们学习了以函数作为参数调用其他的函数，还有嵌套函数，最终我们把一个函数包装在另外的函数中。我们先把第一部分的答案给出：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">print_call</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
<span class="go">…     def fn_wrap(*args, **kwargs):</span>
<span class="go">…         print(&quot;Calling %s with arguments: \n\targs: %s\n\tkwargs:%s&quot; %fn.__name__, args, kwargs))</span>
<span class="go">…         retval = fn(*args, **kwargs)</span>
<span class="go">…         print(&quot;%s returning &#39;%s&#39;&quot; % (fn.func_name, retval))</span>
<span class="go">…         return retval</span>
<span class="go">…     fn_wrap.func_name = fn.func_name</span>
<span class="go">…     return fn_wrap</span>
<span class="go">…</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">greeter</span><span class="p">(</span><span class="n">greeting</span><span class="p">,</span> <span class="n">what</span><span class="o">=</span><span class="s">&#39;world&#39;</span><span class="p">):</span>
<span class="go">…     return &quot;%s %s!&quot; % (greeting, what)</span>
<span class="go">…</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">greeter</span> <span class="o">=</span> <span class="n">print_call</span><span class="p">(</span><span class="n">greeter</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">greeter</span><span class="p">(</span><span class="s">&quot;Hi&quot;</span><span class="p">)</span>
<span class="go">Calling greeter with arguments:</span>
<span class="go">    args: (&#39;Hi&#39;,)</span>
<span class="go">    kwargs:{}</span>
<span class="go">greeter returning &#39;Hi world!&#39;</span>
<span class="go">&#39;Hi world!&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">greeter</span><span class="p">(</span><span class="s">&quot;Hi&quot;</span><span class="p">,</span> <span class="n">what</span><span class="o">=</span><span class="s">&quot;Python&quot;</span><span class="p">)</span>
<span class="go">Calling greeter with arguments:</span>
<span class="go">    args: (&#39;Hi&#39;,)</span>
<span class="go">    kwargs:{&#39;what&#39;: &#39;Python&#39;}</span>
<span class="go">greeter returning &#39;Hi Python!&#39;</span>
<span class="go">&#39;Hi Python!&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这稍微有那么点儿用了，但它可以变的更好！你可能听说过或者没有听说过*闭包*，你可能听说过成千上万种闭包定义中的某一种或者某几种 —— 我不会那么挑剔，我只是说闭包就是一个捕捉了（或者关闭）非本地变量（自由变量）的代码块（比如一个函数）。如果你不清楚我在说什么，你可能需要进修一下 CS 的相关课程，但是不要担心 —— 我会给你演示例子。闭包的概念很简单：一个可以引用在函数闭合范围内变量的函数。</p>
<p>比如说，看一下这个代码：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">get_a</span><span class="p">():</span>
<span class="go">…     return a</span>
<span class="go">…</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_a</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_a</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p>正如你看到的那样， <tt class="docutils literal"><span class="pre">get_a</span></tt> 函数可以取得 <tt class="docutils literal"><span class="pre">a</span></tt> 的值，并且可以读取更新后的值。然而这里有一个限制 —— 被捕获的变量（captured variable，下同）不能被写入。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">set_a</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
<span class="go">…     a = val</span>
<span class="go">…</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">set_a</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">3</span>
</pre></div>
</div>
<p>为什么会这样？由于闭包不能写入任何被捕获的变量， <tt class="docutils literal"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">val</span></tt> 这个语句实际上写入了本地变量 <tt class="docutils literal"><span class="pre">a</span></tt> 从而隐藏了模块级别的 <tt class="docutils literal"><span class="pre">a</span></tt> ，这正是我们想写入的内容。为了解决这个限制（也许这并不是一个好主意），我们可以用一个容器类型：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span> <span class="k">pass</span>
<span class="go">…</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">set_a</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
<span class="go">…     a.value = val</span>
<span class="go">…</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">value</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">set_a</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">value</span>
<span class="go">5</span>
</pre></div>
</div>
<p>因此，我们已经知道了函数从它的闭合范围内捕捉变量，我们最终可以接触到有趣的东西了，我们先实现一个偏函数（partial，下同）。一个偏函数是一个你已经填充了部分或者全部参数的函数的实例；比如说你有一个存储了用户名和密码的会话，和一个查询后端的函数，这个函数有不同的参数但是*总是*需要身份验证。与其说每次都手动传递身份验证信息，我们可以用偏函数来预填充那些信息。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c">#Our &#39;backend&#39; function</span>
<span class="go">… def get_stuff(user, pw, stuff_id):</span>
<span class="go">…     &quot;&quot;&quot;Here we would presumably fetch data using the</span>
<span class="go">…     credentials and id&quot;&quot;&quot;</span>
<span class="go">…     print(&quot;get_stuff called with user: %s, pw: %s, stuff_id: %s&quot; % (user, pw, stuff_id))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">partial</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="go">…     def fn_part(*fn_args, **fn_kwargs):</span>
<span class="go">…         kwargs.update(fn_kwargs)</span>
<span class="go">…         return fn(*args + fn_args, **kwargs)</span>
<span class="go">…     return fn_part</span>
<span class="go">…</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_stuff</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">get_stuff</span><span class="p">,</span> <span class="s">&#39;myuser&#39;</span><span class="p">,</span> <span class="s">&#39;mypwd&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_stuff</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">get_stuff called with user: myuser, pw: mypwd, stuff_id: 3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_stuff</span><span class="p">(</span><span class="mi">67</span><span class="p">)</span>
<span class="go">get_stuff called with user: myuser, pw: mypwd, stuff_id: 67</span>
</pre></div>
</div>
<p>偏函数可以用在许多地方来消除代码的重复。当然，你没有必要自己手动实现它，只需要 <tt class="docutils literal"><span class="pre">from</span> <span class="pre">functools</span> <span class="pre">import</span> <span class="pre">partial</span></tt> 就可以了。</p>
<p>最后，我们来看看函数装饰器（未来可能有类装饰器）。函数装饰器接收一个函数作为参数然后返回一个新的函数。听起来很熟悉吧？我们已经实现过一个 <tt class="docutils literal"><span class="pre">print_call</span></tt> 装饰器了。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nd">@print_call</span>
<span class="go">… def will_be_logged(arg):</span>
<span class="go">…     return arg*5</span>
<span class="go">…</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">will_be_logged</span><span class="p">(</span><span class="s">&quot;!&quot;</span><span class="p">)</span>
<span class="go">Calling will_be_logged with arguments:</span>
<span class="go">    args: (&#39;!&#39;,)</span>
<span class="go">    kwargs:{}</span>
<span class="go">will_be_logged returning &#39;!!!!!&#39;</span>
<span class="go">&#39;!!!!!&#39;</span>
</pre></div>
</div>
<p>使用&#64;符号标记是一个很方便的方法。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">will_be_logged</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
<span class="go">…     return arg*5</span>
<span class="go">…</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">will_be_logged</span> <span class="o">=</span> <span class="n">print_call</span><span class="p">(</span><span class="n">will_be_logged</span><span class="p">)</span>
</pre></div>
</div>
<p>但是如果我们想要确定装饰器的参数呢？在这种情况下，作为装饰器的函数会接收参数，并且返回一个包装（wrap）了装饰器函数的函数。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">require</span><span class="p">(</span><span class="n">role</span><span class="p">):</span>
<span class="go">…     def wrapper(fn):</span>
<span class="go">…         def new_fn(*args, **kwargs):</span>
<span class="go">…             if not role in kwargs.get(&#39;roles&#39;, []):</span>
<span class="go">…                 print(&quot;%s not in %s&quot; % (role, kwargs.get(&#39;roles&#39;, [])))</span>
<span class="go">…                 raise Exception(&quot;Unauthorized&quot;)</span>
<span class="go">…             return fn(*args, **kwargs)</span>
<span class="go">…         return new_fn</span>
<span class="go">…     return wrapper</span>
<span class="go">…</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@require</span><span class="p">(</span><span class="s">&#39;admin&#39;</span><span class="p">)</span>
<span class="go">… def get_users(**kwargs):</span>
<span class="go">…     return (&#39;Alice&#39;, &#39;Bob&#39;)</span>
<span class="go">…</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_users</span><span class="p">()</span>
<span class="go">admin not in []</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="n">File</span> <span class="s">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">7</span><span class="p">,</span> <span class="ow">in</span> <span class="n">new_fn</span>
<span class="gr">Exception</span>: <span class="n">Unauthorized</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_users</span><span class="p">(</span><span class="n">roles</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;user&#39;</span><span class="p">,</span> <span class="s">&#39;editor&#39;</span><span class="p">])</span>
<span class="go">admin not in [&#39;user&#39;, &#39;editor&#39;]</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="n">File</span> <span class="s">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="n">File</span> <span class="s">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">7</span><span class="p">,</span> <span class="ow">in</span> <span class="n">new_fn</span>
<span class="gr">Exception</span>: <span class="n">Unauthorized</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_users</span><span class="p">(</span><span class="n">roles</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;user&#39;</span><span class="p">,</span> <span class="s">&#39;admin&#39;</span><span class="p">])</span>
<span class="go">(&#39;Alice&#39;, &#39;Bob&#39;)</span>
</pre></div>
</div>
<p>就是这样。你现在会写装饰器了，也许你会用这些知识去写面向方面（aspect-oriented）的编程。加入 <tt class="docutils literal"><span class="pre">&#64;cache</span></tt>, <tt class="docutils literal"><span class="pre">&#64;trace</span></tt>, <tt class="docutils literal"><span class="pre">&#64;throttle</span></tt> 都是微不足道的（在你添加 <tt class="docutils literal"><span class="pre">&#64;cache</span></tt> 之前，一定要检查 <tt class="docutils literal"><span class="pre">functools</span></tt> ，如果你用的是 Python 3 的话！）</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Python 的闭包和装饰器</a><ul>
<li><a class="reference internal" href="#part-i">Part I</a></li>
<li><a class="reference internal" href="#part-ii">Part II</a></li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../sources/issue3/python-closures-and-decorators.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li><a href="../index.html">PyCoder&#39;s Weelky CN</a> &raquo;</li>
          <li><a href="index.html" >issue 3: Code Hard</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, PyCodersCN.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>