A Guide to Python's Magic Methods
=================================

储存你的对象
------------

如果你接触过其他的 Pythoner，你可能已经听说过 Pickle 了， Pickle 是用来序列化 Python 数据结构的模块，在你需要暂时存储一个对象的时候（比如缓存），这个模块非常的有用，不过这同时也是隐患的诞生地。

序列化数据是一个非常重要的功能，所以他不仅仅拥有相关的模块（ ``Pickle`` , ``cPickle`` ），还有自己的协议以及魔术方法，不过首先，我们先讨论下关于序列化内建数据结构的方法。

Pickling: 简单例子
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

让我们深入研究 Pickle，比如说你现在需要临时储存一个字典，你可以把它写入到一个文件里，并且要小心翼翼的确保格式正确，之后再用 exec() 或者处理文件输入来恢复数据，实际上这是很不安全的，如果你使用文本存储了一些重要的数据，任何方式的改变都可能会影响到你的程序，轻则程序崩溃，重则被恶意程序利用，所以，让我们用 Pickle 代替这种方式：

::
    
    import pickle
    
    data = {'foo': [1, 2, 3],
            'bar': ('Hello', 'world!'),
            'baz': True}
    jar = open('data.pkl', 'wb')
    pickle.dump(data, jar) # write the pickled data to the file jar
    jar.close()

嗯，过了几个小时之后，我们需要用到它了，只需把它 unpickle 了就行了：

::
    
    import pickle
    
    pkl_file = open('data.pkl', 'rb') # connect to the pickled data
    data = pickle.load(pkl_file) # load it into a variable
    print data
    pkl_file.close()

正如你期望的，数据原封不动的回来了！

同时要给你一句忠告： pickle 并不是很完美， Pickle 文件很容易被不小心或者故意损坏， Pickle 文件比纯文本文件要稍微安全一点，但是还是可以被利用运行恶意程序。 Pickle 不是跨版本兼容的（译注：最近刚好在 《Python Cookbook》上看到相关讨论，书中描述的 Pickle 是跨版本兼容的，此点待验证），所以尽量不要去分发 Pickle 过的文本，因为别人并不一定能够打开。不过在做缓存或者其他需要序列化数据的时候， Pickle 还是很有用处的。

序列化你自己的对象
^^^^^^^^^^^^^^^^^^

Pickle 并不是只支持内建数据结果，任何遵循 Pickle 协议的类都可以，Pickle 协议为 Python 对象规定了4个可选方法来自定义 Pickle 行为（对于 C 扩展的 cPickle 模块会有一些不同，但是这并不在我们的讨论范围内）：

``__getinitargs__(self)``

如果你希望在逆序列化的同时调用 ``__init__`` ，你可以定义 ``__getinitargs__`` 方法，这个方法应该返回一系列你想被 ``__init__`` 调用的参数，注意这个方法只对老样式的类起作用。

``__getnewargs__(self)``

对于新式的类，你可以定义任何在重建对象时候传递到 ``__new__`` 方法中的参数。这个方法也应该返回一系列的被 ``__new__`` 调用的参数。

``__getstate__(self)``

你可以自定义当对象被序列化时返回的状态，而不是使用 ``__dict`` 方法，当逆序列化对象的时候，返回的状态将会被 ``__setstate__`` 方法调用。

``__setstate__(self, state)``

在对象逆序列化的时候，如果 ``__setstate__`` 定义过的话，对象的状态将被传给它而不是传给 ``__dict__`` 。这个方法是和 ``__getstate__`` 配对的，当这两个方法都被定义的时候，你就可以完全控制整个序列化与逆序列化的过程了。

例子
^^^^

我们以 Slate 为例，这是一段记录一个值以及这个值是何时被写入的程序，但是，这个 Slate 有一点特殊的地方，当前值不会被保存。

::
    
    import time
    
    class Slate:
        '''Class to store a string and a changelog, and forget its value when
        pickled.'''
    
        def __init__(self, value):
            self.value = value
            self.last_change = time.asctime()
            self.history = {}
    
        def change(self, new_value):
            # Change the value. Commit last value to history
            self.history[self.last_change] = self.value
            self.value = new_value
            self.last_change = time.asctime()
    
        def print_changes(self):
            print 'Changelog for Slate object:'
            for k, v in self.history.items():
                print '%s\t %s' % (k, v)
    
        def __getstate__(self):
            # Deliberately do not return self.value or self.last_change.
            # We want to have a "blank slate" when we unpickle.
            return self.history
    
        def __setstate__(self, state):
            # Make self.history = state and last_change and value undefined
            self.history = state
            self.value, self.last_change = None, None

结论
^^^^

这份指南的希望为所有人都能带来一些知识，即使你是 Python 大牛或者对于精通于面向对象开发。如果你是一个 Python 初学者，阅读这篇文章之后你已经获得了编写丰富，优雅，灵活的类的知识基础了。如果你是一个有一些经验的 Python 程序员，你可能会发现一些能让你写的代码更简洁的方法。如果你是一个 Python 大牛，可能会帮助你想起来一些你已经遗忘的知识，或者一些你还没听说过的新功能。不管你现在有多少经验，我希望这次对于 Python 特殊方法的旅程能够带给你一些帮助（用双关语真的很不错 XD）（译注: 这里的双关在于标题为 Magic Methods 这里是 神奇的旅程 ，不过由于中英语序的问题，直译略显头重脚轻，所以稍微变化了下意思，丢掉了双关的含义）。

附录：如何调用魔术方法
^^^^^^^^^^^^^^^^^^^^^^

一些魔术方法直接和内建函数相对，在这种情况下，调用他们的方法很简单，但是，如果是另外一种不是特别明显的调用方法，这个附录介绍了很多并不是很明显的魔术方法的调用形式。

+---------------------------------+-----------------------------------+---------------------------------+
| 魔术方法                        | 调用方式                          | 解释                            |
+=================================+===================================+=================================+
| __new__(cls [,...])             | instance = MyClass(arg1, arg2)    | __new__ 在创建实例的时候被调用  |
+---------------------------------+-----------------------------------+---------------------------------+
| __init__(self [,...])           | instance = MyClass(arg1, arg2)    | __init__ 在创建实例的时候被调用 |
+---------------------------------+-----------------------------------+---------------------------------+
| __cmp__(self, other)            | self == other, self > other, 等。 | 在比较的时候调用                |
+---------------------------------+-----------------------------------+---------------------------------+
| __pos__(self)                   | +self                             | 一元加运算符                    |
+---------------------------------+-----------------------------------+---------------------------------+
| __neg__(self)                   | -self                             | 一元减运算符                    |
+---------------------------------+-----------------------------------+---------------------------------+
| __invert__(self)                | ~self                             | 取反运算符                      |
+---------------------------------+-----------------------------------+---------------------------------+
| __index__(self)                 | x[self]                           | 对象被作为索引使用的时候        |
+---------------------------------+-----------------------------------+---------------------------------+
| __nonzero__(self)               | bool(self)                        | 对象的布尔值                    |
+---------------------------------+-----------------------------------+---------------------------------+
| __getattr__(self, name)         | self.name # name 不存在           | 访问一个不存在的属性时          |
+---------------------------------+-----------------------------------+---------------------------------+
| __setattr__(self, name, val)    | self.name = val                   | 对一个属性赋值时                |
+---------------------------------+-----------------------------------+---------------------------------+
| __delattr__(self, name)         | del self.name                     | 删除一个属性时                  |
+---------------------------------+-----------------------------------+---------------------------------+
| __getattribute(self, name)      | self.name                         | 访问任何属性时                  |
+---------------------------------+-----------------------------------+---------------------------------+
| __getitem__(self, key)          | self[key]                         | 使用索引访问元素时              |
+---------------------------------+-----------------------------------+---------------------------------+
| __setitem__(self, key, val)     | self[key] = val                   | 对某个索引值赋值时              |
+---------------------------------+-----------------------------------+---------------------------------+
| __delitem__(self, key)          | del self[key]                     | 删除某个索引值时                |
+---------------------------------+-----------------------------------+---------------------------------+
| __iter__(self)                  | for x in self                     | 迭代时                          |
+---------------------------------+-----------------------------------+---------------------------------+
| __contains__(self, value)       | value in self, value not in self  | 使用 in 操作测试关系时          |
+---------------------------------+-----------------------------------+---------------------------------+
| __concat__(self, value)         | self + other                      | 连接两个对象时                  |
+---------------------------------+-----------------------------------+---------------------------------+
| __call__(self [,...])           | self(args)                        | “调用”对象时                    |
+---------------------------------+-----------------------------------+---------------------------------+
| __enter__(self)                 | with self as x:                   | with 语句环境管理               |
+---------------------------------+-----------------------------------+---------------------------------+
| __exit__(self, exc, val, trace) | with self as x:                   | with 语句环境管理               |
+---------------------------------+-----------------------------------+---------------------------------+
| __getstate__(self)              | pickle.dump(pkl_file, self)       | 序列化                          |
+---------------------------------+-----------------------------------+---------------------------------+
| __setstate__(self)              | data = pickle.load(pkl_file)      | 序列化                          |
+---------------------------------+-----------------------------------+---------------------------------+

希望这个表格对你对于什么时候应该使用什么方法这个问题有所帮助。
